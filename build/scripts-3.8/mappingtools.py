#!/home/lfp/miniconda3/bin/python
# Copyright (C) <2020> PMBL;South China Agricultural University. All rights reserved
__author__ = "Write by Fangping Li"
__version__ = '0.1.0'

import argparse
import sys
import os

def get_options():    
    example = "./mappingtools.py -i pangenome.fa -1 illnumina_R1.fq.gz -2 illnumina_R3.fq.gz -g guide.goc -l location.lg -o outputcov" 
    description = "Create one-by-one mapping and pav example: " + example
    parser = argparse.ArgumentParser(description = description,prog = 'mappingtools.py')
    parser.add_argument('-i', '--inpan', action='store',type=str,help='input your reference .fasta')
    parser.add_argument('-t', '--threads', action='store',type=int,default=1,help='how many thread do you want to use')
    parser.add_argument('-b', '--inbase', action='store',type=int,help='how many base-pair will you consider it as a total insertion rather than a replace',default=20)
    parser.add_argument('-1', '--pairend1', action='store',type=str,help='input your pairend1 .fastq')
    parser.add_argument('-2', '--pairend2', action='store',type=str,help='input your pairend2 .fastq') 
    parser.add_argument('-l', '--location', action='store',type=str,
                         help='location of software "mummer" "lastz" and "svmu","samtools","bowtie"',default="location.lg")
    parser.add_argument('-g', '--gocguide', action='store',type=str,help='input your .goc file generated by multiple.py')
    parser.add_argument('-o', '--output', action='store',type=str,
                         help='name of the  pan-genome coverage output',default="output")
    parser.add_argument('-clean', '--clean', action='store',type=str,choices=('yes','no'),
                             help='Clean all of the middle file!"',default="no")
    return parser.parse_args()

def acm(a):
    b=len(a)  
    sum=0  
    for i in a:  
        sum=sum+i  
    mn = sum/b
    return mn 

gosome = get_options()
location = gosome.location


parame = open(location,"r") #mum lastz svmu samtools bowtie2 location
parameline = list(parame.readlines())
mum = parameline[0].split("=")[1].strip()
lastz = parameline[1].split("=")[1].strip()
svmu = parameline[2].split("=")[1].strip()
bowtie2 = parameline[3].split("=")[1].strip()
samtools = parameline[4].split("=")[1].strip()
p1=gosome.pairend1
p2=gosome.pairend2

parame.close()
panin = gosome.inpan
print(bowtie2+"bowtie2-build "+"--threads "+str(gosome.threads)+" "+panin+" "+panin)
os.system(bowtie2+"bowtie2-build "+"--threads "+str(gosome.threads)+" "+panin+" "+panin)
print("begin mapping")
na1 = os.system("bosm.sh "+bowtie2+" "+panin+" "+samtools+" "+p1+" "+p2+" "+panin+" "+str(gosome.threads))

if na1 ==0:
    print("mapping done")
    mapout=panin+".sort.bam"
else:
    print("mapping error!")
    quit()

    
gocguide = gosome.gocguide
goc = open(gocguide,"r")
gocl = list(goc.readlines())
goc.close()
golist2 = open("golist2","w")
for i in gocl:
    if i.find("Org")==-1:
        i = i.split()
        loc1 = i[2]
        loc2 = i[5]
        ch = i[1]
        print("cadepth.sh "+samtools+" "+mapout+" "+ch+" "+loc1+" "+loc2,file = golist2)

golist2.close()
na2 = os.system("parallel --jobs "+str(gosome.threads)+" < golist2")

if na2 == 0:
    print("Cov acquire done!")
else:
    print("Cov acquire error!")

finaloutput = open(gosome.output,"w")#open the .goc file again and let the .goc file guide the acquire of coverage     
for i in gocl:#cov acquire go!
    ref = []
    que =[]
    if i.find("Org")==-1:
        i = i.split()
        ch = i[1]
        loc1 = i[2]
        loc2 = i[3]
        loc3 = i[4]
        loc4 = i[5]
        filename = mapout+"_"+ch+"_"+loc1+"_"+loc4+".bam.depth" #open the .depth file by the guide of coverage
        filename = open(filename,"r")
        filenamego = list(filename.readlines())
        filename.close()
        if int(loc1) - int(loc2) > gosome.inbase:#how many base-pair will you consider it as a total insertion rather than a replace

            filename.close()
            for j in filenamego:#judge the location of depth
                j = j.split()
                if int(j[1])>= int(loc1) and int(j[1])< int(loc2):
                    ref.append(int(j[2]))
                if int(j[1])>= int(loc3) and int(j[1])< int(loc4):
                    que.append(int(j[2]))
            refm = acm(ref)
            quem = acm(que)
        else:
            refm = -1
            for j in  filenamego:
                if int(j[1])>= int(loc3) and int(j[1])< int(loc4):
                    que.append(int(j[2])) 
            quem = acm(que) #mean caculate
        print(ch+"	"+loc1+"	"+loc2+"	"+loc3+"	"+loc4+"	",file = finaloutput,end = "	")
        print(refm,file = finaloutput,end = "	")
        print(quem,file = finaloutput)

finaloutput.close()    

if gosome.clean == "yes":
    os.system("rm *depth")
    os.system("rm *chr*_*_*.bam")
            
print("done!")
print("Your ouput is "+ gosome.output)

                    
                
                
            
            
            
        
    
